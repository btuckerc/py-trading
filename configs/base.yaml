# Base configuration for the trading stack

# Universe definition
# The 'universe' section defines the default universe settings.
# For more flexibility, see 'universes' section below for named universe definitions.
universe:
  index_name: "SP500"
  constituents_csv_path: "data/sp500_constituents.csv"
  min_price_usd: 3.0
  min_dollar_volume_window: 20
  min_dollar_volume_percentile: 10
  use_survivorship_bias_free: true  # If true, uses universe_membership table

# Named universe definitions
# Each universe can have its own index_name, filters, and constraints.
# Use universe_registry.get_universe() with a universe name to get asset_ids.
universes:
  # Default S&P 500 universe for research
  sp500_research:
    index_name: "SP500"
    min_price_usd: 3.0
    min_dollar_volume_percentile: 10
    use_survivorship_bias_free: true
    description: "S&P 500 with survivorship-bias-free membership"
  
  # S&P 500 for live trading (same as research by default)
  sp500_live:
    index_name: "SP500"
    min_price_usd: 5.0                 # Slightly higher price floor for live
    min_dollar_volume_percentile: 20   # Higher liquidity requirement for live
    use_survivorship_bias_free: true
    description: "S&P 500 with stricter liquidity filters for live trading"
  
  # All assets in database (no index membership filter)
  all_assets:
    index_name: null                   # No index filter
    min_price_usd: 1.0
    use_survivorship_bias_free: false
    description: "All assets in database, minimal filters"

# Default universe names for different modes
universe_defaults:
  backtest: "sp500_research"
  live: "sp500_live"

# Data vendors
vendors:
  primary: "yahoo"  # Options: yahoo, tiingo, finnhub
  fallback: "yahoo"

# Data maintenance and coverage
# Used by scripts/ensure_data_coverage.py and data/maintenance.py
data:
  min_history_start_date: "2020-01-01"  # Earliest date to guarantee bar coverage
  max_history_lag_days: 1               # Max days behind "today" that data can be
  auto_fetch_on_backtest: true          # Auto-fetch missing data when running backtests
  auto_fetch_on_live: true              # Auto-fetch missing data when running live loop
  # symbols: []                         # Optional: explicit symbol list (if empty, uses universe)
  
# Database paths
database:
  duckdb_path: "data/market.duckdb"
  data_root: "data"
  raw_vendor_dir: "data/raw_vendor"
  normalized_dir: "data/normalized"

# Feature engineering
features:
  technical:
    enabled: true
    windows: [1, 5, 20, 60, 120]
    ma_windows: [5, 10, 20, 50, 100, 200]
    ema_windows: [10, 20, 50]
  cross_sectional:
    enabled: true
  fundamentals:
    enabled: true  # Requires fundamentals data ingestion (Tiingo/Finnhub)
  sentiment:
    enabled: true  # Requires news data ingestion (Finnhub/Tiingo) - will be empty if no news data available
  calendar:
    enabled: true
  options:
    enabled: false
  microstructure:
    enabled: false
  regimes:
    enabled: true   # Add regime_id as a feature (requires regimes table to be populated)
    include_probabilities: false  # Include regime transition probabilities (GMM only)

# Labeling
labels:
  horizons: [1, 5, 20, 120]  # days
  benchmark_symbol: "SPY"
  compute_excess_returns: true
  compute_binary_labels: true

# Benchmarks for performance comparison
benchmarks:
  # Named benchmark definitions
  definitions:
    sp500:
      name: "S&P 500"
      ticker: "SPY"
      description: "S&P 500 Index ETF"
    dow:
      name: "Dow Jones"
      ticker: "DIA"
      description: "Dow Jones Industrial Average ETF"
    nasdaq:
      name: "Nasdaq Composite"
      ticker: "QQQ"
      description: "Nasdaq-100 Index ETF"
  
  # Default benchmarks to use when none specified (all three by default)
  default:
    - sp500
    - dow
    - nasdaq
  
  # Primary benchmark for alpha calculations (used as reference in summaries)
  primary: sp500

# Models
models:
  baseline:
    enabled: true
    types: ["logistic", "xgboost", "lightgbm"]
  sequence:
    enabled: true
    sequence_length: 60
    architectures: ["conv_lstm", "tcn"]
  uncertainty:
    method: "mc_dropout"  # Options: mc_dropout, mean_variance
    mc_samples: 50

# Portfolio
portfolio:
  strategies:
    - name: "long_top_k"
      enabled: true
      k: 20
      min_score_threshold: 0.0
      min_confidence: 0.7
    - name: "long_short_deciles"
      enabled: false   # Set to true to enable long/short variant
      long_decile: 10
      short_decile: 1
      market_neutral: true
      regime_aware: true
      disable_shorts_in_crisis: false  # Set true to disable shorts in bear_high_vol
  risk:
    max_position_pct: 0.20      # Max 20% per position (prevents single-stock concentration)
    min_position_pct: 0.02      # Min 2% to avoid tiny positions
    max_sector_pct: 0.40        # Max 40% per sector
    max_gross_exposure: 1.0
    max_net_exposure: 1.0       # 1.0 for long-only strategies
    stop_loss_pct: 0.10
  drawdown:
    throttle_threshold_pct: 0.15   # Start throttling at 15% drawdown
    max_drawdown_pct: 0.25         # Full throttle at 25% drawdown
    min_scale_factor: 0.25         # Minimum 25% of normal position size
    recovery_threshold_pct: 0.05   # Resume full exposure when DD < 5%
  
  # Regime-aware exposure policy
  # Maps regime descriptors to gross exposure multipliers
  # Updated 2025-11-28 based on regime_metrics_2020-01-01_2024-12-31.json
  regime_policy:
    enabled: true
    exposure_multipliers:
      bull_low_vol: 1.0       # Full exposure - best regime (Sharpe 1.09, DD 2.0%)
      bull_high_vol: 0.40     # Reduced from 0.8 - volatile bull underperformed (Sharpe -5.16)
      bear_low_vol: 0.70      # Increased from 0.5 - grinding bear was actually OK (Sharpe 0.50)
      bear_high_vol: 0.25     # Minimal exposure in crisis (Sharpe -3.00, DD 4.1%)
  
  # VIX-style volatility-based position sizing
  volatility_scaling:
    enabled: true
    target_vol: 0.15          # Target annualized portfolio volatility
    vol_floor: 0.10           # Minimum vol assumption (prevents over-leverage)
    vol_ceiling: 0.60         # Maximum vol assumption (prevents over-reduction)
    lookback_days: 20         # Days for realized vol calculation
    # Scale factor = target_vol / realized_vol, clamped by floor/ceiling
  
  # Defensive sector rotation per regime
  sector_policy:
    enabled: true
    # Sector tilts by regime (positive = overweight, negative = underweight)
    # Values are additive adjustments to base sector caps
    tilts:
      bull_low_vol:
        # Favor growth/cyclical in good times
        Technology: 0.05
        Consumer Discretionary: 0.05
        Financials: 0.03
        Utilities: -0.05
        Consumer Staples: -0.05
      bull_high_vol:
        # Balanced, slight quality tilt
        Health Care: 0.03
        Technology: 0.02
        Consumer Discretionary: -0.02
      bear_low_vol:
        # Favor defensive sectors
        Consumer Staples: 0.10
        Health Care: 0.08
        Utilities: 0.08
        Technology: -0.10
        Consumer Discretionary: -0.10
        Financials: -0.05
      bear_high_vol:
        # Maximum defensive positioning
        Consumer Staples: 0.15
        Health Care: 0.10
        Utilities: 0.10
        Technology: -0.15
        Consumer Discretionary: -0.15
        Financials: -0.10
        Industrials: -0.05

# Transaction costs
costs:
  commission_bps: 1.0  # 1 basis point per trade
  slippage_model: "simple"  # Options: simple, volatility_based
  slippage_bps: 2.0

# Backtesting
backtest:
  initial_capital: 100000.0
  rebalance_frequency: "daily"  # Options: daily, weekly, monthly
  execution_lag: 1  # Execute at open of day t+1 for decisions made at close of day t
  cost_sensitivity_levels: [0, 5, 10, 20]  # bps per side to test
  walk_forward:
    enabled: false
    train_years: 3
    test_years: 1
    step_months: 12

# Training
training:
  time_splits:
    - name: "split_1"
      train_start: "2000-01-01"
      train_end: "2014-12-31"
      val_start: "2015-01-01"
      val_end: "2016-12-31"
      test_start: "2017-01-01"
      test_end: "2018-12-31"
    - name: "split_2"
      train_start: "2002-01-01"
      train_end: "2016-12-31"
      val_start: "2017-01-01"
      val_end: "2018-12-31"
      test_start: "2019-01-01"
      test_end: "2020-12-31"

# =============================================================================
# Model Retraining Policy
# =============================================================================
# Controls how and when models are retrained to incorporate new information.
# This policy applies to backtests (walk-forward), simulations, and live trading.
retraining:
  # Cadence: how often to retrain (in trading days)
  # Options: 5 (weekly), 10 (biweekly), 20 (monthly), 60 (quarterly)
  cadence_days: 20
  
  # History window: how much historical data to use for training
  # Options: "rolling" (fixed window) or "expanding" (all data from anchor)
  window_type: "rolling"
  window_years: 5  # For rolling: use last N years; for expanding: minimum years required
  
  # Time-decay weighting for training samples
  # Recent samples get higher weight: w(t) = exp(-lambda * age_in_days)
  # Higher lambda = more emphasis on recent data (Prophet-style)
  time_decay:
    enabled: true
    lambda: 0.001  # Decay rate (0.001 = ~37% weight at 1000 days old)
    min_weight: 0.1  # Floor to prevent old data from being ignored entirely
  
  # Adaptive retraining: trigger early retrain if performance degrades
  adaptive:
    enabled: true
    # Performance thresholds (rolling window metrics)
    sharpe_floor: -0.5  # Retrain if rolling 60-day Sharpe drops below this
    hit_rate_floor: 0.40  # Retrain if rolling hit rate drops below 40%
    calibration_threshold: 2.0  # Retrain if realized/predicted variance ratio exceeds this
    lookback_days: 60  # Window for computing rolling metrics
  
  # Model versioning
  versioning:
    enabled: true
    artifact_dir: "artifacts/models"
    keep_versions: 10  # Number of old versions to keep
    # Regularization to prevent drastic changes between versions
    stability_penalty: 0.1  # L2 penalty on prediction changes vs prior model

# Live trading
live:
  enabled: false
  broker: "paper"  # Options: paper, alpaca, ibkr
  schedule_time: "16:00"  # After market close (ET)
  execution_time: "09:30"  # Market open (ET)
  retrain_frequency_days: 30
  
  # Regime-aware trading controls
  regime_aware: true           # Enable regime-based exposure scaling
  sector_tilts: true           # Enable defensive sector rotation
  vol_scaling: true            # Enable VIX-style volatility scaling
  drawdown_throttle: true      # Enable drawdown-based position scaling
  
  # Tradability filter
  # Filters research universe to broker-tradable symbols
  tradability_filter:
    enabled: true              # Enable tradability filtering
    policy: "renormalize"      # Options: renormalize, cash, warn, error
    # renormalize: Redistribute untradable weight to tradable assets
    # cash: Park untradable weight in cash
    # warn: Log warning but proceed with untradable assets removed
    # error: Raise error if any assets are untradable
  
  # Safety controls
  max_daily_orders: 50         # Maximum orders per day
  min_order_value: 100         # Minimum order value in USD
  max_position_value: 50000    # Maximum single position value
  skip_if_logged: true         # Skip if already ran for this date
  
  # Cloud deployment
  heartbeat_enabled: true
  heartbeat_path: "logs/live_trading/heartbeat.json"
  max_runtime_minutes: 30
  
  # Monitoring
  alert_on_regime_change: true
  alert_on_drawdown_throttle: true
  alert_on_high_vol: true
  high_vol_threshold: 0.30     # Alert if realized vol > 30%

# Logging
logging:
  level: "INFO"
  file: "logs/trading_stack.log"
  console: true

# =============================================================================
# Quantitative Gates for Live Trading
# =============================================================================
# These gates must be satisfied before moving from paper to live trading.
# Run scripts/check_live_readiness.py to verify all gates are met.

live_gates:
  # Paper trading soak period
  min_paper_trading_days: 30          # Minimum days of paper trading
  min_paper_trades: 50                # Minimum trades executed in paper mode
  
  # Performance gates (from paper trading period)
  max_paper_drawdown_pct: 0.20        # Max acceptable drawdown in paper mode
  max_paper_volatility: 0.40          # Max acceptable annualized volatility
  min_paper_sharpe: 0.0               # Minimum Sharpe ratio (0 = don't require positive)
  
  # Backtest alignment gates
  max_backtest_divergence_pct: 0.10   # Max divergence between paper and backtest returns
  
  # System health gates
  max_consecutive_errors: 3           # Max consecutive daily errors before halt
  min_data_coverage_pct: 0.95         # Min % of expected data present
  
  # Initial live allocation (as % of total intended capital)
  initial_live_allocation_pct: 0.05   # Start with 5% of capital
  
  # Ramp-up schedule (after gates are met)
  ramp_up_schedule:
    - days: 30
      allocation_pct: 0.05    # 5% for first 30 days
    - days: 60
      allocation_pct: 0.10    # 10% for days 31-60
    - days: 90
      allocation_pct: 0.25    # 25% for days 61-90
    - days: 120
      allocation_pct: 0.50    # 50% for days 91-120
    - days: 180
      allocation_pct: 1.0     # 100% after 180 days

